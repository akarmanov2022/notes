---
tags:
  - JavaConcurrency
  - Java
  - Книга
links: "[[Java Concurrency]]"
---
Эта глава посвящена использованию конкурентных строительных блоков, таких как *коллекции* и [[Строительные блоки#Синхронизаторы|Синхронизаторы]].

# Синхронизированные коллекции
К *синхронизированным классам коллекций* относятся `Vector` и `HashTable` и оберточные классы, создаваемые фабричными методами `Collections.synchronyzedXxx`.

## Проблемы синхронизации коллекций
Требуется блокировка на стороне клиента для защиты составных действий, таких как итеративный обход, навигация и условные операции.

>Составные действия над объектом `Vector`, которые могут привести к запутанным результатам

```Java
class Vector {
 //...
 public static Object getLast(Vector list) {
  int lastIndex = list.size() - 1;
  return list.get(lastSize);
 }
 public static void deleteLast(Vector list) {
  int lastIndex = list.size() - 1;
  list.remove(lastSize);
 }
}
```

Синхронизированные коллекции поддерживают блокировку на стороне клиента, поэтому существует возможность создания новых операций, атомарных по отношению к другим операциям над коллекцией, если известен замок.

>Составные действия над объектом `Vector`, с использование блокировки на стороне клиента

```Java
class Vector {
 //...
 public static Object getLast(Vector list) {
  synchronized (list) {
	int lastIndex = list.size() - 1;
	return list.get(lastSize);
  }
 }
 public static void deleteLast(Vector list) {
  synchronized (list) {
   int lastIndex = list.size() - 1;
   list.remove(lastSize);
  }
 }
}
```

## Итераторы и исключение CuncurrentModificationException

Итераторы синхронизированных коллекций не проектировались для конкурентного выполнения изменений, поэтому, обнаружив во время итеративного обхода изменения в коллекции, они выдают исключение CME.
Чтобы предотвратить исключению CME, надо владеть коллекционным замком в течение всего времени итеративного обхода.

Альтернативой запиранию коллекции во время итеративного обхода является ее клонирование и итеративный обход клона. Клон ограничен одним потоком, но коллекция все равно должна быть защищена замком во время клонирования. 

## Скрытые итераторы

> Инкасулирование синхронизации упрощает усиление ее политики

# Конкурентные коллекции

Синхронизированные коллекции обеспечивают потокобезопасность, сериализуя весь доступ к своему состоянию. Стоимость этого подхода равна слабой конкурентости.

`ConcurrentHashMap` вместо `SynchronyzedHashMap`
`CopyOnWriteArrayList` вместо `SynchronnyzedList`

Новый интерфейс `ConcurrentMap` поддерживает распространенные составные действия, такие как операция "добавить, если отсутствует", замена и условное удаление.

>Замена синхронизированных коллекций конкурентными коллекциям может предложить значительные улучшения масштабируемости при небольшом риске.

Есть два типа коллекций: `Queue` и `BlokingQueue`.
`Queue` предназначен для временного хранения множества элементов во время ожидания ими обработки. Операции над очередью не блокируют продвижение элементов по ней. Если очередь является пустой, то операция извлечения возвращает `null`. 

`BlockingQueue` расширяет `Queue`, добавляя блокирующие операции вставки и извлечения. Если очередь является пустой, то операция извлечения будет заблокирована до тех пор, пока в ней не появится один элемент. Соответственно, если очередь заполнена, то операция вставки будет заблокирована до появления свободного места. Блокирующие очереди полезны в паттернах проектирования [[Produces-Consumer (Производитель-Потребитель)]]

## ConcurrentHashMap

Класс `ConcurrentHashMap` - это хешированный ассоциативный массив `Map`, аналогичный `HashMap`, но использующий другую замковую стратегию. Вместо синхронизации всех методов на общем замке и ограничения доступа одним потоком за раз он использует *замковое расщепление на полосы*. Результатом является высокая пропускная способность в рамках кокурентного доступа с небольшим штрафом на производительность для однопоточного доступа.

> *Замковое расщепление на полосы* - обеспечивает конкурентность между читающими потоками, между читателями и писателями и между писателями.

Также `ConcurrentHashMap` предоставляет итераторы, которые не выдают исключение CME, являются не быстро отказывающими и слабо непротиворечивыми. Они допускают конкуретное выполнение изменений, перебирают элементы в том порядке, в каком они существовали при конструировании итератора, и могут отражать изменения в коллекцию.

В некоторых случаях: таких как атомарное добавление нескольких соответствий или итеративный обход `Map` несколько раз, необходимо видеть одни и те же элементы в одном и том же порядке. Тогда с помощью `HashTable` и `synchronyzedMap` возможно пойти на компромисс и приобрести замок эксклюзивного доступа `Map`.

### Дополнительные атомарные операции ConcurrentHashMap

- добавить, если отсутствует
- удалить, если равно
- заменить, если равно

## CopyOnWriteArrayList

`CopyOnWriteArrayList` является конкуретной версией синхронизированного `List`, который предлагает более высокую конкуретность и устраняет необходимость в блокировке или клонировании коллекции во время итеративного обхода.

При создании и публикации копи коллекции после каждого ее изменения реализуется мутируемость.  Итераторы сохраняют ссылку на резервный массив, который был актуальным в начале итеративного обхода, и так как он никогда ни изменяется, синхронизация им нужна ненадолго - чтобы обеспечить видимость содержимого массива. Потоки могут выполнять итеративный обход коллекции, не мешая потоками, желающим изменить ее.

Очевидно, что копирование резервного массива сопряжено с определенной стоимостью, и его целесообразно использовать *только тогда, когда итеративный обход встречается чаще, чем изменение*.

# Блокирующие очереди

Блокирующие очереди предоставляют методы `put` и `take` а также хронометрированные эквиваленты `offer` и `poll`.
 - `put` - блокирует продвижение до тех пор, пока не освободится место в заполненной очереди
 - `take` - блокирует продвижение до появления элемента в пустой очереди.
Неимитированные очереди никогда не заполняются полностью, поэтому метод `put` в них отсутствует.

Блокирующие очереди поддерживают паттерн проектирования [[Produces-Consumer (Производитель-Потребитель)]].

Блокирующие очереди упрощают кодирование потребителей благодаря методу `take`. Если производители не генерируют работу достаточно быстро, потребители просто ждут. Это приемлемо как в серверном приложении, где ни один клиент не запрашивает заданий, так и веб-обходчике, в котором существует бесконечная работа.

Если производители неуклонно генерируют работу быстрее, чем потребители могут ее обработать, то со временем у приложения заполняется память. Метод `put` упрощает кодирование производителей, благодаря чему в ограниченной очереди у потребителей есть время, чтобы нивелировать сове отставание.

Метод `offset` возвращает статус сбоя, если элемент не может быть размещен в очереди. Это позволяет создавать политики для работы с перегрузкой, такие как сброс нагрузки, сериализация избыточных рабочих элементов и запись их на диск и регулирование числа производящих потоков

>Ограниченные очереди делают приложение устойчивым к перегрузкам.

## Серийное ограничение одним потоком

Паттерны [[Produces-Consumer (Производитель-Потребитель)]] и блокирующие очереди поддерживают *серийное ограничение одним потоком* мутируемых объектов. Эксклюзивное владение объектом может быть перенесено другому потоку путем безопасной публикации. Исходный владелец не будет касаться объекта снова, а новый владелец может свободно его изменять.

## Двухсторонние очереди и кража работы

`Deque` - это двусторонная очередь, которая позволяет эффективно вставлять и удалять как голову очереди, так и ее хвост. Реализации `Deque`: `ArrayDeque` и `LinkedBlokingDeque`

Двусторонние очереди поддаются паттерну 