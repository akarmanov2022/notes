---
tags:
  - JavaConcurrency
  - Java
  - Книга
links: "[[Java Concurrency]]"
---
Эта глава посвящена использованию конкурентных строительных блоков, таких как *коллекции* и [[Строительные блоки#Синхронизаторы|Синхронизаторы]].

# Синхронизированные коллекции
К *синхронизированным классам коллекций* относятся `Vector` и `HashTable` и оберточные классы, создаваемые фабричными методами `Collections.synchronyzedXxx`.

## Проблемы синхронизации коллекций
Требуется блокировка на стороне клиента для защиты составных действий, таких как итеративный обход, навигация и условные операции.

>Составные действия над объектом `Vector`, которые могут привести к запутанным результатам

```Java
class Vector {
 //...
 public static Object getLast(Vector list) {
  int lastIndex = list.size() - 1;
  return list.get(lastSize);
 }
 public static void deleteLast(Vector list) {
  int lastIndex = list.size() - 1;
  list.remove(lastSize);
 }
}
```

Синхронизированные коллекции поддерживают блокировку на стороне клиента, поэтому существует возможность создания новых операций, атомарных по отношению к другим операциям над коллекцией, если известен замок.

>Составные действия над объектом `Vector`, с использование блокировки на стороне клиента

```Java
class Vector {
 //...
 public static Object getLast(Vector list) {
  synchronized (list) {
	int lastIndex = list.size() - 1;
	return list.get(lastSize);
  }
 }
 public static void deleteLast(Vector list) {
  synchronized (list) {
   int lastIndex = list.size() - 1;
   list.remove(lastSize);
  }
 }
}
```

## Итераторы и исключение CuncurrentModificationException

Итераторы синхронизированных коллекций не проектировались для конкурентного выполнения изменений, поэтому, обнаружив во время итеративного обхода изменения в коллекции, они выдают исключение CME.
Чтобы предотвратить исключению CME, надо владеть коллекционным замком в течение всего времени итеративного обхода.

Альтернативой запиранию коллекции во время итеративного обхода является ее клонирование и итеративный обход клона. Клон ограничен одним потоком, но коллекция все равно должна быть защищена замком во время клонирования. 

## Скрытые итераторы

> Инкасулирование синхронизации упрощает усиление ее политики

# Конкурентные коллекции

Синхронизированные коллекции обеспечивают потокобезопасность, сериализуя весь доступ к своему состоянию. Стоимость этого подхода равна слабой конкурентости.

`ConcurrentHashMap` вместо `SynchronyzedHashMap`
`CopyOnWriteArrayList` вместо `SynchronnyzedList`

Новый интерфейс `ConcurrentMap` поддерживает распространенные составные действия, такие как операция "добавить, если отсутствует", замена и условное удаление.

>Замена синхронизированных коллекций конкурентными коллекциям может предложить значительные улучшения масштабируемости при небольшом риске.

Есть два типа коллекций: `Queue` и `BlokingQueue`.
`Queue` предназначен для временного хранения множества элементов во время ожидания ими обработки. Операции над очередью не блокируют продвижение элементов по ней. Если очередь является пустой, то операция извлечения возвращает `null`. 

`BlockingQueue` расширяет `Queue`, добавляя блокирующие операции вставки и извлечения. Если очередь является пустой, то операция извлечения будет заблокирована до тех пор, пока в ней не появится один элемент. Соответственно, если очередь заполнена, то операция вставки будет заблокирована до появления свободного места. Блокирующие очереди полезны в паттернах проектирования [[Produces-Consumer (Производитель-Потребитель)]]

## ConcurrentHashMap

Класс `ConcurrentHashMap` - это хешированный ассоциативный массив `Map`, аналогичный `HashMap`, но использующий другую замковую стратегию. Вместо синхронизации всех методов на общем замке и ограничения доступа одним потоком за раз он использует *замковое расщепление на полосы*. Результатом является высокая пропускная способность в рамках кокурентного доступа с небольшим штрафом на производительность для однопоточного доступа.

> *Замковое расщепление на полосы* - обеспечивает конкурентность между читающими потоками, между читателями и писателями и между писателями.

Также `ConcurrentHashMap` предоставляет итераторы, которые не выдают исключение CME, являются не быстро отказывающими и слабо непротиворечивыми. Они допускают конкуретное выполнение изменений, перебирают элементы в том порядке, в каком они существовали при конструировании итератора, и могут отражать изменения в коллекцию.

В некоторых случаях: таких как атомарное добавление нескольких соответствий или итеративный обход `Map` несколько раз, необходимо видеть одни и те же элементы в одном и том же порядке. Тогда с помощью `HashTable` и `synchronyzedMap` возможно пойти на компромисс и приобрести замок эксклюзивного доступа `Map`.

### Дополнительные атомарные операции ConcurrentHashMap

- добавить, если отсутствует
- удалить, если равно
- заменить, если равно

## CopyOnWriteArrayList

`CopyOnWriteArrayList` является конкуретной версией синхронизированного `List`, который предлагает более высокую конкуретность и устраняет необходимость в блокировке или клонировании коллекции во время итеративного обхода.

При создании и публикации копи коллекции после каждого ее изменения реализуется мутируемость.  Итераторы сохраняют ссылку на резервный массив, который был актуальным в начале итеративного обхода, и так как он никогда ни изменяется, синхронизация им нужна ненадолго - чтобы обеспечить видимость содержимого массива. Потоки могут выполнять итеративный обход коллекции, не мешая потоками, желающим изменить ее.

Очевидно, что копирование резервного массива сопряжено с определенной стоимостью, и его целесообразно использовать *только тогда, когда итеративный обход встречается чаще, чем изменение*.

# Блокирующие очереди

Блокирующие очереди предоставляют методы `put` и `take` а также хронометрированные эквиваленты `offer` и `poll`.
 - `put` - блокирует продвижение до тех пор, пока не освободится место в заполненной очереди
 - `take` - блокирует продвижение до появления элемента в пустой очереди.
Неимитированные очереди никогда не заполняются полностью, поэтому метод `put` в них отсутствует.

Блокирующие очереди поддерживают паттерн проектирования [[Produces-Consumer (Производитель-Потребитель)]].

Блокирующие очереди упрощают кодирование потребителей благодаря методу `take`. Если производители не генерируют работу достаточно быстро, потребители просто ждут. Это приемлемо как в серверном приложении, где ни один клиент не запрашивает заданий, так и веб-обходчике, в котором существует бесконечная работа.

Если производители неуклонно генерируют работу быстрее, чем потребители могут ее обработать, то со временем у приложения заполняется память. Метод `put` упрощает кодирование производителей, благодаря чему в ограниченной очереди у потребителей есть время, чтобы нивелировать сове отставание.

Метод `offset` возвращает статус сбоя, если элемент не может быть размещен в очереди. Это позволяет создавать политики для работы с перегрузкой, такие как сброс нагрузки, сериализация избыточных рабочих элементов и запись их на диск и регулирование числа производящих потоков

>Ограниченные очереди делают приложение устойчивым к перегрузкам.

## Серийное ограничение одним потоком

Паттерны [[Produces-Consumer (Производитель-Потребитель)]] и блокирующие очереди поддерживают *серийное ограничение одним потоком* мутируемых объектов. Эксклюзивное владение объектом может быть перенесено другому потоку путем безопасной публикации. Исходный владелец не будет касаться объекта снова, а новый владелец может свободно его изменять.

## Двухсторонние очереди и кража работы

`Deque` - это двусторонная очередь, которая позволяет эффективно вставлять и удалять как голову очереди, так и ее хвост. Реализации `Deque`: `ArrayDeque` и `LinkedBlokingDeque`

Двусторонние очереди поддаются паттерну [[Work stealing (Кража работы)]].

# Блокирующие и прерываемые методы

Потоки могут *блокировать* продвижение, если:
- ожидают завершения ввода-вывода
- ожидают приобретения замка
- ожидают пробуждения ото сна `Thread.sleep`
- ожидают результата вычисления в другом потоке.

В состоянии `BLOCKED`, `WAITING` или `TIMED_WATING`, поток не контролирует задачу, завершение которой ожидает,  и возвращается в состояние работоспособности `RUNNABLE` только после возникновения внешнего события.

Прерывание представляет собой *кооперативный механизм*.
Когда поток А пытается прерывать поток В: то просто просит поток В прекратить это делать. Отменой длительных действий занимаются не потоки, а блокирующие очереди.

Вызвав метод, который выдает исключение `InterruptedExeption`, код должен становиться блокирующим и должен уметь откликаться на прерывание двумя способами:
- **Распространить исключение** `InterruptedExeption`. 
- **Восстановить прерывание**. Когда распространить исключение невозможно: необходимо перехватить исключение и восстановить статус прерванности, вызвав `interrupt` в текущем потоке: чтобы код выше в стеке вызовов видел выполненное прерывание
# Синхронизаторы

*Синхронизатор* - это любой объект, координирующий поток управления в остальных потоках, основываясь на их состоянии. В качестве синхронизаторов могут выступать [[Строительные блоки#Блокирующие очереди|блокирующие очереди]], [[Строительные блоки#Семафоры|семафоры]], [[Строительные блоки#Барьеры|барьеры]] и [[Строительные блоки#Защелки (latch)|защелки]].

Все синхронизаторы инкасулируют состояние, которое определяет, пропускать или отправлять в ожидание поступающие потоки. 

## Защелки (latch)

*Защелка (latch)* - синхронизатор, который может задерживать продвижение потоков до достижения своего конечного состояния. Он действует как закрытый шлюз, который в определенный момент разрешает всем потокам пройти, и навсегда остается открытым.
Защелки сдерживают некие действия до завершения других действий, например:
- инициализация ресурсов.
- запуск служб
- готовность всех участников

Реализации защелки в Java:
- `CountDownLatch`
- `FutureTask`
## Семафоры
*Счетный семафор (counting semaphores)* - синхронизаторы, регулирующие число действий, способных обращаться к определенному ресурсу или выполнять одну и ту же задачу в одно и то же время. Семафоры можно использовать для реализации пулов или лимитов на коллекцию.

Класс `Semaphore` управляет набором виртуальных разрешений. Начальное число разрешений передается конструктору класса `Semaphore`. Действия могут приобретать разрешения и освобождать их, когда работа с ними закончена. Если разрешения отсутствуют, метод `acquire` блокирует продвижение до тех пор, пока не появится хотя бы одно из них. Метод `release` возвращает разрешение семафору. 

## Барьеры

*Барьеры (barriers)* - синхронизаторы, подобные защелкам в том, что они блокируют группу потоков до наступления какого-то события. Но в отличие от защелки барьер заставляет потоки вместе проходить барьерную точку *в одно и то же время*, чтобы продолжить работу. Защелки предназначены для ожидания событий, а барьеры - для ожидания других потоков.

Класс `CyclicBarrier` позволяет фиксированному числу сторон неоднократно назначать встречу в барьерной точке. Он полезен в параллельных итеративных алгоритмах, которые разбивают задачу на фиксированное число независимых подзадач. Потоки достигают барьерной точки и вызывают метод `await` для ожидания остальных потоков.

Еще одной формой барьера является обменник `Exchanger` - двусторонний барьер, в котором стороны обмениваются данными в барьерной точке. Обменники полезны, когда стороны выполняют ассиметричные действия, например, когда один поток заполняет буфер данными, а другой потребляет данные из буфера. Потоки могут использовать `Exchanger` для встречи и обмена полного буфера на пустой. Такой обмен является безопасной публикацией объектов.

