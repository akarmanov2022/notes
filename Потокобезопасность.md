---
tags:
  - JavaConcurrency
  - Java
links:
  - "[[Java Concurrency]]"
---
Если многочисленные потоки обращаются к одной и той же переменной, имеющей мутируемое состояние, без синхронизации, то программа неисправна.
Способы ее исправить
- не использовать переменную состояния совместно во всех потоках
- сделать переменную состояния немтируемой
- при каждом доступе к переменной состояния использовать синхронизацию.

***

При проектировании потокобезопасных классов  хорошие ООП решения
- [[Инкапсуляция]]
- Немутируемость
- Четкая спецификация инвариантов

***

# Что такое потокобезопасность?

 Потокобезопасный класс - это класс, который себя правильно во время доступа из многочисленных потоков, независимо от того, как выполнение этих потоков планируется или перемежается рабочей средой, и без дополнительной синх. или другой координации со стороны вызывающего кода.
***
Потокобезопасные классы должны инкасулировать свою синхронизацию сами и не нуждаться в помощи клиентов.
***
Объекты без поддержки внутреннего состояния всегда являются потокобезопасными.
# Атомарность

Операции `A` и `B` - атомарные, если, с точки зрения потока, выполняющего операцию `A`, операция `B` либо была целиком выполнена другим потоком, либо не выполнена даже частично.
***
Для сохранения непротиворечивости состояний обновляйте родственные переменные состояния в единой атомарной операции.

# Защита состояния с помощью замков

Все обращения к мутируемой переменной состояния должны выполняться с удержанием одного и того же замка. Только тогда переменная защищена этим замком.
***
Для каждого инварианта, который включает более одной переменной, все переменные, участвующие в инварианте, должны быть защищены тем же замком.

# Живучесть и производительность

При реализации политики синхронизации не поддавайтесь искушению пожертвовать простотой ради производительности.
***
Следует избегать ударжания блокировки во время длительных вычислений или операций, таких как сетевой или консольный IO.
***

