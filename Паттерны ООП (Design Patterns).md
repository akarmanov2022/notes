# Что такое Паттерны Проектирования?

> [!NOTE] Кристофер Александера 
> Любой паттерн проектирования описывает задачу, которая снова и снова возникает в нашей работе, а также принцип ее решения, причем таким образом, что это решение можно потом использовать миллион раз, при этом никакие две реализации не будут полностью одинаковыми.

В общем случае паттерн состоит из следующих элементов:
- **Имя**: Описывает проблему проектирования, ее решение и последствия
- **Задача**: Описание того, как следует применять паттерн.
- **Решение**: Описание элементов дизайна паттерна, отношений между ними, их обязанностей и взаимодействий между ними.
- **Результат**: Следствие применения паттерна.

# Каталог Паттернов Проектирования

### [[Abstract Factory (абстрактная фабрика)]]
Предоставляет интерфейс для создания семейств связанных между собой или зависимых объектов без указания их конкретных классов
### [[Adapter (адапетр)]]
Преобразует интерфейс класса в другой интерфейс, ожидаемый клиентами. Обеспечивает совместную работу классов, которая была бы невозможно без данного паттерна из-за несовместимости интерфейсов.
### [[Bridge (мост)]]
Отделяет абстракцию от реализации, чтобы их можно было изменять независимо друг от друга
### [[Builder (строитель)]]
Отделяет конструирование сложного объекта от его представления, чтобы один процесс конструирования мог использоваться для создания различных представлений
### [[Chain of Responsibility (цепочка обязанностей)]]
Можно избежать формирования жестокой связи между отправителем запроса и его получателем, для чего возможность обработки запроса предоставляется нескольким объектам. Объектны-получатели объединяются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-либо объектом
### [[Command (команда)]]
Инкапсулирует запрос в виде объекта, позволяя тем самым параметризовывать клиентов по типу запроса, ставить запросы в очередь, протоколировать их и поддерживать отмену выполнения операции
### [[Composite (компоновщик)]]
Группирует объекты в древовидные структуры для представления иерархии типа *часть — целое*. Позволяет клиентам работать с единичными объектами так же, как с группами объектов
### [[Decorator (декоратор)]]
Динамически наделяет объект новыми обязанностями. Декораторы применяются для расширения существующей функциональности и являются гибкой альтернативой порождению подклассов
### [[Facade (фасад)]]
Предоставляет унифицированный интерфейс к набору интерфейсов в некоторой подсистеме. Определяет интерфейс более высокого уровня, облегчающий работу с подсистемой
### [[Factory Method (фабричный метод)]]
Определяет интерфейс для создания объектов, позволяя подклассам решить, экземпляр какого класса следует создать. Позволяет классу передать ответственность за создание экземпляра в подклассы
### [[Flyweight (приспособленец)]]
Применяет механизм совместного использования для эффективной поддержки большого числа мелких объектов
### [[Interpreter (интерпретер)]]
 Для заданного языка определяет представление его грамматики вместе с интерпретатором, который использует представление для интерпретации предложений языка
### [[Iterator (итератор)]]
Дает возможность последовательно обойти все элементы составного объекта, не раскрывая его внутреннего представления.
### [[Mediator (посредник)]]
Определяет объект, в котором инкапсулирована информация о взаимодействии объектов из некоторого множества. Способствует ослаблению связей между объектами, позволяя им работать без явных ссылок друг на друга. Это, в свою очередь, дает возможность независимо изменять схему взаимодействия
### [[Memento (хранитель)]]
Позволяет без нарушения инкапсуляции получать и сохранять во внешней памяти внутреннее состояние объекта, чтобы позже объект можно было восстановить в точно таком же состоянии
### [[Observer (наблюдатель)]]
Определяет между объектами зависимость типа **один-ко-многим**, так что при изменении состояния одного объекта все зависящие от него получают уведомление и автоматически обновляются
### [[Prototype (прототип)]]
Описывает виды создаваемых объектов с помощью прототипа и создает новые объекты путем его копирования
### [[Proxy (заместитель)]]
Подменяет другой объект для контроля доступа к нему
### [[Singelton (одиночка)]]
Гарантирует, что некоторый класс может существовать толко в одном экземпляре, и предоставляет глобальную точку доступа к нему
### [[State (состояние)]]
Позволяет объекту изменять свое поведение при модификации внутреннего состояния. При этом все выглядит так, словно поменялся класс объекта
### [[Strategy (стратегия)]]
Определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого. Позволяет менять алгоритм независимо от клиента, который им пользуется
### [[Template Method (шаблонный метод)]]
Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам переопределять отдельные шаги алгоритма, не меняя его общей структуры
### [[Visitor (посетитель)]]
Представляет операцию, которую надо выполнит над элементами объектной структуры. Позволяет определить новую операцию без изменения классов элементов, к которым он применяется


