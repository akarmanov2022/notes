---
tags:
  - JavaConcurrency
  - Java
links:
  - "[[Java Concurrency]]"
---
# Проектирование потокобезопасного класса

Этапа:
- идентификация переменных, формирующих состояние объекта
- идентификация инвариантов, ограничивающих переменные состояния
- создание политики для управления конкурентным доступом к состоянию

*Политика синхронизации* определяет, как объект координирует доступ к своему состоянию, и указывает, какая комбинация немутируемости, ограничения одним потоком и блокировки используется сейчас, какие переменные и какими замками защищены сейчас.

## Сбор требований к синхронизации

Инварианты класса - идентификаторы состояния как валидного и невалидного.

## Операции, зависимые от состояния

Операции, зависимые от состояния - операции с предусловиями.

Предусловия, например, запрещают удалять элемент из пустой очереди, требуя для удаления состояние очереди «не пусто»

# Ограничение одним экземпляром

Использование ограничения одним экземпляром

```Java
@ThreadSafe
public class PersonSet {
	@GuardedBy("this")
	private final Set<Person> mySet = new HashSet<Person>();
	
	public synchronized void addPerson(Person p) {
		mySet.add(p);
	}
	public synchronized boolean containsPerson(Person p) {
		return mySet.contains(p);
	}
}
```

Ограничение одним экземпляром упрощает создание потокобезопасных классов, позволяя анализировать их потокобезопасность без проверки всей программы.

Защита состояния с помощью приватного замка
```Java
public class PrivateLock {
	private final Object myLock = new Object();
	@GuardedBy("myLock") Widget widget;
	
	void someMethod() {
		synchronized(myLock) {
		// Обратиться и изменить состояние виджета
		}
	}
}
```