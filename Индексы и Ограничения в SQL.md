---
tags:
  - SQL
  - СУБД
links:
  - "[[SQL]]"
---
# Индексы

Для поиска записей в таблице сервер СУБД должен посетить каждую строку в таблице и проверить содержимое на соответствие требованию запроса. Этот тип доступа известен как *сканирование таблицы* (Table scan)

Этот метод хорошо работает для таблиц с небольшим количеством записей. Однако для таблиц с большим количеством записей запросы к ним становятся очень тяжелыми. Здесь должны помощь один или несколько индексов для таблицы.

## Создание индекса

Пример создания индекса:
```mysql
ADD INDEX idx_email (email);
```
или
```sql
CREATE INDEX idx_email
ON customer (email);
```
C помощью этой команды по-умолчанию будет создан B-tree индекс.

При наличии индекса оптимизатор запросов может использовать индекс, если это считается полезным. Если в таблице есть более одного индекса, оптимизатор должен решить, какой индекс будет наиболее выгодным для конкретной инструкции SQL.

### Уникальный индекс

Пример создания уникального индекса
```sql
CREATE UNIQUE INDEX idx_email
ON table_name (email)
```

Уникальный индекс играет множество ролей.
Наряду с предоставлением всех преимуществ обычного индекса, он также служит механизмом для запрета дублирования значений в индексированном столбце.

### Индекс нескольких столбцов

Создание одного индекса на несколько столбцов таблицы полезно, если происходит поиск записей в таблице по этим столбцам. Однако, следует помнить, что эффективно индекс будет работать в случае поиска по первому и второму, либо только по первому столбу, указанному при создании индекса.




## Типы индексов

Один индекс неспособен работать с несколькими типами данных с одинаковой эффективностью. В каждый конкретный сценарий следует выбирать индекс определенного типа.
### B-Tree индекс

> Этот тип индексов используется по-умолчанию в СУБД.

*B-Tree* - это balanced-tree индекс, работающий по принципу самобалансирующегося дерева с одним или множеством уровней ветвления узлов. Узлы ветви используются для навигации по дереву, листовые узлы используются для хранения актуальных значений.
![[Pasted image 20240530221046.png]]

По мере того, как строки вставляются, обновляются и удаляются из таблицы, сервер будет пытаться сбалансировать дерево, чтобы на одной стороне корневого узла не было гораздо больше узлов ветвей/листьев, чем на другой. Сервер может добавлять или удалять узлы ветвления для более равномерного перераспределения значений и может даже добавлять или удалять весь уровень узлов ветвления. Уравновешивая дерево, сервер может быстро переходить к узлам листьев, чтобы найти нужные значения без необходимости перемещаться по многим уровням узлов ветви.

*B-tree* индексы идеально подходят для обработки столбцов, которые содержат множество различных значений, таких как фамилия или имя. Однако, для столбов с ограниченным кол-вом значений они могут стать излишни и громоздки.
В таких случаях лучше использовать *Растровые индексы*
### Растровые индексы (Bitmap Indexes)

*Растровые индексы* были созданы в Oracle. Они генерируют растровое изображение для каждого значения в столбце. В дальнейшем при поиске записей по этому столбцу сервер СУБД сможет быстро определить нужные записи в таблице.

*Растровые индексы* - это хорошее, компактное решение для индексации данных с низкой кардинальностью, но эта стратегия индексации разрушается, если количество значений, хранящихся в столбце, поднимается слишком высоко по отношению к количеству строк (известных как данные с высокой кардинальностью), так как серверу нужно будет поддерживать слишком много растровых изображений. Например, вы никогда не будете создавать растровый индекс в столбце первичного ключа, так как он представляет собой максимально возможную мощность (различное значение для каждой строки).

Пример создания bitmap индекса
```sql
CREATE BITMAP INDEX idx_active ON customer (active);
```

Растровые индексы обычно используются в средах хранения данных, где большие объемы данных, как правило, индексируются в столбцах, содержащих относительно мало значений (например, кварталы продаж, географические регионы, продукты, продавцы).