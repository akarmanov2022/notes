---
tags:
  - SQL
  - СУБД
links:
  - "[[SQL]]"
---
# Индексы

Для поиска записей в таблице сервер СУБД должен посетить каждую строку в таблице и проверить содержимое на соответствие требованию запроса. Этот тип доступа известен как *сканирование таблицы* (Table scan)

Этот метод хорошо работает для таблиц с небольшим количеством записей. Однако для таблиц с большим количеством записей запросы к ним становятся очень тяжелыми. Здесь должны помощь один или несколько индексов для таблицы.

## Создание индекса

Пример создания индекса:
```mysql
ADD INDEX idx_email (email);
```
или
```sql
CREATE INDEX idx_email
ON customer (email);
```
C помощью этой команды по-умолчанию будет создан B-tree индекс.

При наличии индекса оптимизатор запросов может использовать индекс, если это считается полезным. Если в таблице есть более одного индекса, оптимизатор должен решить, какой индекс будет наиболее выгодным для конкретной инструкции SQL.

### Уникальный индекс

Пример создания уникального индекса
```sql
CREATE UNIQUE INDEX idx_email
ON table_name (email)
```

Уникальный индекс играет множество ролей.
Наряду с предоставлением всех преимуществ обычного индекса, он также служит механизмом для запрета дублирования значений в индексированном столбце.

### Индекс нескольких столбцов

Создание одного индекса на несколько столбцов таблицы полезно, если происходит поиск записей в таблице по этим столбцам. Однако, следует помнить, что эффективно индекс будет работать в случае поиска по первому и второму, либо только по первому столбу, указанному при создании индекса.




## Типы индексов

Один индекс неспособен работать с несколькими типами данных с одинаковой эффективностью. В каждый конкретный сценарий следует выбирать индекс определенного типа.
### B-Tree индекс

> Этот тип индексов используется по-умолчанию в СУБД.

*B-Tree* - это balanced-tree индекс, работающий по принципу самобалансирующегося дерева с одним или множеством уровней ветвления узлов. Узлы ветви используются для навигации по дереву, листовые узлы используются для хранения актуальных значений.
![[Pasted image 20240530221046.png]]

По мере того, как строки вставляются, обновляются и удаляются из таблицы, сервер будет пытаться сбалансировать дерево, чтобы на одной стороне корневого узла не было гораздо больше узлов ветвей/листьев, чем на другой. Сервер может добавлять или удалять узлы ветвления для более равномерного перераспределения значений и может даже добавлять или удалять весь уровень узлов ветвления. Уравновешивая дерево, сервер может быстро переходить к узлам листьев, чтобы найти нужные значения без необходимости перемещаться по многим уровням узлов ветви.

*B-tree* индексы идеально подходят для обработки столбцов, которые содержат множество различных значений, таких как фамилия или имя. Однако, для столбов с ограниченным кол-вом значений они могут стать излишни и громоздки.
В таких случаях лучше использовать *Растровые индексы*
### Растровые индексы (Bitmap Indexes)

*Растровые индексы* были созданы в Oracle. Они генерируют растровое изображение для каждого значения в столбце. В дальнейшем при поиске записей по этому столбцу сервер СУБД сможет быстро определить нужные записи в таблице.

*Растровые индексы* - это хорошее, компактное решение для индексации данных с низкой кардинальностью, но эта стратегия индексации разрушается, если количество значений, хранящихся в столбце, поднимается слишком высоко по отношению к количеству строк (известных как данные с высокой кардинальностью), так как серверу нужно будет поддерживать слишком много растровых изображений. Например, вы никогда не будете создавать растровый индекс в столбце первичного ключа, так как он представляет собой максимально возможную мощность (различное значение для каждой строки).

Пример создания bitmap индекса
```sql
CREATE BITMAP INDEX idx_active ON customer (active);
```

Растровые индексы обычно используются в средах хранения данных, где большие объемы данных, как правило, индексируются в столбцах, содержащих относительно мало значений (например, кварталы продаж, географические регионы, продукты, продавцы).

### Текстовые индексы (Text indexes)

Если СУБД хранит документы, то важно дать пользователям возможность использовать поиск по словам или фразам в документах. Стандартные индексы здесь не подойдут.
Для этого в СУБД MySQL, SQL Server и Oracle Database содержатся специальные индексы и поисковые механизмы.

В MySQL, SQL Server - *full-text* индексы
В Oracle Database - *Oracle Text* библиотека

## Недостатки индексов

Ключ к пониманию того, почему больше индексов не обязательно хорошо, заключается в том, чтобы иметь в виду, что каждый индекс является таблицей (особый тип таблицы, но все же таблица). Поэтому каждый раз, когда строка добавляется в таблицу или удаляется из нее, все индексы в этой таблице должны быть изменены. При обновлении строки любые индексы в столбце или столбцах, которые были затронуты, должны быть изменены.

Также индексы требуют дискового пространства и администрирования.

Советы:
- Убедитесь, что все столбцы первичного ключа индексируются (большинство серверов автоматически создают уникальные индексы при создании ограничений первичного ключа). Для многоколонных первичных ключей рассмотрите возможность создания дополнительных индексов на подмножестве столбцов первичного ключа или на всех столбцах первичного ключа, но в порядке, отличном от определения ограничения первичного ключа.
- Постройте индексы для всех столбцов, на которые ссылаются ограничения внешнего ключа. Имейте в виду, что сервер проверяет, чтобы убедиться, что нет дочерних строк при удалении родителя, поэтому он должен выдать запрос для поиска определенного значения в столбце. Если в столбце нет индекса, необходимо отсканировать всю таблицу.
- Индексируйте любые столбцы, которые будут часто использоваться для получения данных. Большинство столбцов даты являются хорошими кандидатами, наряду с короткими (от 2 до 50 символов) строковыми столбцами.
